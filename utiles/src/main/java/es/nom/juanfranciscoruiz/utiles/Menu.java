package es.nom.juanfranciscoruiz.utiles;

import es.nom.juanfranciscoruiz.utiles.constants.MenuConstants;
import es.nom.juanfranciscoruiz.utiles.exceptions.MenuErrors;
import es.nom.juanfranciscoruiz.utiles.exceptions.MenuException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

import static es.nom.juanfranciscoruiz.utiles.Util.*;

/**
 * It's the representation of an options menu, capable of generating a view of
 * this menu for output devices or streams and for getting the user's
 * response.
 * <p>
 * When you want to display the menu, assuming the Menu instance is called
 * principalMenu, it would look something like this:
 * <p>
 * IO io = new IOimpl(); io.prt(principalMenu.getMenuView());
 *
 * @author Juan F. Ruiz
 */
public class Menu {
    // static variables and constants
    /**
     * For debugging.
     */
    private final static Logger logger = LoggerFactory.getLogger(Menu.class);

    /**
     * Default value for the title property of a Menu Object.
     */
    private static final String NO_TITLE = "Untitled";
    /**
     * For a Menu object that is the Home Menu this is the option 0 of the menu
     * for exiting the application.
     */
    private static final String EXITOPT = "0. Exit the application";
    /**
     * Default vale for the message shown to the user below the list options.
     */
    private static final String DEFAULT_MSG = "Make your selection:";
    /**
     * Constant for the wrong option.
     */
    public static final Long WRONG_OPTION = -1L;

    //Properties
    /**
     * List of options for the menu.
     */
    private List<String> options;
    /**
     * Title of the menu.
     */
    private String title;
    /**
     * Message to be displayed below the list of options.
     */
    private String message;
    /**
     * The option selected by the user.
     */
    private Long selectedOption;
    /**
     * Indicates whether this menu is the application's main menu.
     */
    private boolean isRootMenu;
    /**
     * Represents the layout or visual representation of a menu in the application.
     * This variable typically holds information about how the menu is displayed
     * or rendered, such as its configuration or style.
     * Their content will generated by the generateMenuView() method.
     */
    private String menuView;
    /**
     * The submenus of this menu, or null if this is a leaf menu.
     */
    private List<Menu> subMenus;
    /**
     * The parent menu of this menu, or null if this is a root menu.
     */
    private Menu parentMenu;

    // Constructors

    /**
     * Instantiate a Menu object.
     * By default, the menu is not the root menu and has no title or message, but it has a default
     * value for the title property (because title is mandatory), a blank string for the message
     * property (message can't be null), and an empty list for the options property.
     */
    public Menu() throws MenuException {
        this.setOptions(new ArrayList<>());
        this.setSubMenus(new ArrayList<>());
        this.setRootMenu(false);
        this.setTitle(MenuConstants.NO_TITLE);
        this.setMessage("");
        this.menuView = "";
        this.setSelectedOption(0L);
    }

    /**
     * Instantiate a Menu object with the specified parameters
     *
     * @param options    A list of options
     * @param title      A string with the menu title
     * @param message    A string containing the message that will be displayed
     *                   below the list of options
     * @param isRootMenu Boolean indicating whether it is the application's main
     *                   menu, which will add the option "0. Exit the application" to the options
     *                   property.
     */
    public Menu(List<String> options, String title, String message,
                boolean isRootMenu) throws MenuException {
        this.setOptions(new ArrayList<>());
        this.setSubMenus(new ArrayList<>());
        if (options != null && !options.isEmpty()) {
            for (String option : options) {
                this.addOption(option);
            }
        } else {
            this.setOptions(new ArrayList<>());
        }

        if (title != null && !title.isEmpty()) {
            this.setTitle(title);
        } else {
            this.setTitle(MenuConstants.NO_TITLE);
        }
        this.setMessage(message);

        this.setRootMenu(isRootMenu);
        if (this.isRootMenu()) {
            this.getOptions().addFirst(MenuConstants.EXITOPT);
        }
    }

    /**
     * Instantiate a Menu object with the specified parameters and submenus.
     *
     * @param options    A list of options
     * @param title      A string with the menu title
     * @param message    A string containing the message that will be displayed below the
     *                   list of options
     * @param isRootMenu Boolean indicating whether it is the application's main menu,
     *                   which will add the option "0. Exit the application" to the
     *                   options property.
     * @param subMenus   A list of submenus (can't be null because throws MenuException)
     * @param parentMenu The parent menu of this menu, or null if this is the
     *                   main menu.
     *                   <p>
     *                   if the client class tries to set a parent menu to a root menu,
     *                   it will throw a MenuException) because a root menu can't have
     *                   a parent menu.
     * @throws MenuException In case of error
     */
    public Menu(List<String> options, String title, String message, boolean isRootMenu,
                List<Menu> subMenus, Menu parentMenu) throws MenuException {
        this(options, title, message, isRootMenu);
        if (subMenus == null) {
            throw new MenuException(MenuErrors.ERR_SUBMENUS_CANNOT_BE_NULL);
        }
        this.setSubMenus(subMenus);
        if (isRootMenu) {
            if (parentMenu != null) {
                throw new MenuException(MenuErrors.ERR_ROOTMENU_CANT_HAVE_A_PARENT_MENU);
            }
        } else {
            if (parentMenu != null) {
                this.setParentMenu(parentMenu);
            } else {
                throw new MenuException(MenuErrors.ERR_SUBMENU_MUST_HAVE_A_PARENT_MENU);
            }
        }
    }

    //Getters and Setters

    /**
     * Gets the list of menu options
     *
     * @return A list of strings with the options.
     */
    public List<String> getOptions() {
        return options;
    }

    /**
     * Sets the menu options list
     *
     * @param options A list of strings with the new menu options.
     */
    public void setOptions(List<String> options) throws MenuException {
        if (options == null) {
            throw new MenuException(MenuErrors.ERR_OPTIONS_CANNOT_BE_NULL);
        }
        int i = 0;
        int index = 1;
        for (String option : options) {
            options.set(i, addNumbertoOptionMenu(option, index));
            i++;
            index++;
        }

        if (this.getOptions() != null) {
            this.options.addAll(options);
        } else {
            this.options = options;
        }

        if (this.isRootMenu() && !this.getOptions().contains(MenuConstants.EXITOPT)) {
            this.options.addFirst(MenuConstants.EXITOPT);
        }
    }

    /**
     * Gets the menu title
     *
     * @return a string with the menu title
     */
    public String getTitle() {
        return title;
    }

    /**
     * Set the menu title.
     * The title can't be null for a valid menu object.
     *
     * @param title A chain with the new menu title
     * @throws MenuException If the title is null
     */
    public void setTitle(String title) throws MenuException {
        if (title == null) {
            throw new MenuException(MenuErrors.ERR_TITLE_CANNOT_BE_NULL);
        }
        this.title = title;
    }

    /**
     * Gets the message from the menu
     *
     * @return a string with the current menu message
     */
    public String getMessage() {
        return message;
    }

    /**
     * Set a new message in the menu.
     * A valid message can't be null.
     *
     * @param message A string with the new menu message
     * @throws MenuException If the message is null
     */
    public void setMessage(String message) throws MenuException {
        if (message == null) {
            throw new MenuException(MenuErrors.ERR_MESSAGE_CANNOT_BE_NULL);
        }
        this.message = message;
    }

    /**
     * Gets the option currently selected by the user (after calling the
     * awaitResponse() method).
     *
     * @return a long with the option selected by the user
     */
    public Long getSelectedOption() {
        return selectedOption;
    }

    /**
     * Set the selected option
     *
     * @param selectedOption A long file with the selected option
     */
    public void setSelectedOption(Long selectedOption) {
        this.selectedOption = selectedOption;
    }

    /**
     * Returns a boolean indicating whether this menu is the application's main
     * menu.
     *
     * @return a boolean, if true it indicates that the current menu is the main
     * menu (root menu) of the application and false otherwise.
     */
    public boolean getIsRootMenu() {
        return isRootMenu();
    }


    /**
     * The parent menu of this menu, or null if this is the main menu.
     */
    public Menu getParentMenu() {
        if (parentMenu == null) {
            return null;
        }
        return parentMenu;
    }

    /**
     * Sets the specified menu as the parent menu for the current menu.
     * If the current menu is a root menu, an exception will be thrown as a root menu cannot have a parent.
     *
     * @param parentMenu the menu to be set as the parent menu. Must not be null.
     * @throws MenuException if the current menu is a root menu and cannot have a parent.
     */
    public void setParentMenu(Menu parentMenu) throws MenuException {
        if (this.isRootMenu) {
            throw new MenuException(MenuErrors.ERR_ROOTMENU_CANT_HAVE_A_PARENT_MENU);
        }

        if (parentMenu == null) {
            this.parentMenu = null;
            return;
        }
        if (parentMenu.equals(this)) {

            throw new MenuException(MenuErrors.ERR_MENU_CANNOT_HAVE_ITSELF_AS_PARENT);
        }
        this.parentMenu = parentMenu;
    }


    /**
     * Sets whether the current menu is a root menu or not.
     * A root menu is the top-level menu that does not have a parent menu.
     * This method also adjusts options accordingly based on the root menu state.
     *
     * @param isRootMenu a boolean indicating if the current menu is a root menu.
     *                   If true, the menu is designated as a root menu;
     *                   otherwise, it is considered a sub-menu.
     * @throws MenuException if the current menu has a parent menu and is being set as a root menu.
     */
    public void setIsRootMenu(boolean isRootMenu) throws MenuException {
        if (this.getParentMenu() != null) {
            throw new MenuException(MenuErrors.ERR_SUBMENU_SET_AS_ROOT);
        }
        this.setRootMenu(isRootMenu);

        if (this.getOptions() == null) {
            this.setOptions(new ArrayList<>());
        }

        if (this.isRootMenu()) {
            this.getOptions().addFirst(MenuConstants.EXITOPT);
        } else {
            this.getOptions().remove(MenuConstants.EXITOPT);
            this.getOptions().addFirst(MenuConstants.BACKTOPARENTMENU);
            this.setTitle("(" + this.getTitle() + ")");
        }
    }

    /**
     * Retrieves the current state of the menu view as a String.
     * The menu view is generated internally before being returned.
     *
     * @return the generated menu view as a String
     */
    public String getMenuView() {
        this.generateMenuView();
        return this.menuView;
    }

    /**
     * Generates a formatted menu view and sets it to the corresponding field.
     * <p>
     * This method constructs a visual representation of a menu using the instance's
     * title, options, and a message. The title is formatted with decorative borders,
     * each option is displayed in sequence, and the message is appended at the end.
     * The final formatted menu view is stored in the appropriate field using
     * the {@code setMenuView} method.
     * <p>
     * The menu structure includes:
     * - A title surrounded by star borders that adjust to the title's length.
     * - A list of options provided by the instance's {@code getOptions} method.
     * - A concluding message provided by the instance's {@code getMessage} method.
     */
    public void generateMenuView() {
        final String LS = System.lineSeparator();
        StringBuilder sb = new StringBuilder();
        StringBuilder sbMenuView = new StringBuilder();

        sb.append(LS);
        int longitud = this.getTitle().length();
        String repeat = "*".repeat(Math.max(0, longitud + 5));
        sb.append(repeat);

        sb.append(LS);
        sb.append("  ").append(this.getTitle()).append("  ");
        sb.append(LS);
        sb.append(repeat);

        String tit = sb.toString();
        sbMenuView.append(tit);
        sbMenuView.append(LS);
        sbMenuView.append(LS);
        for (String opcion : this.getOptions()) {
            sbMenuView.append(opcion);
            sbMenuView.append(LS);
        }
        sbMenuView.append(LS);
        sbMenuView.append(this.getMessage());
        sbMenuView.append(LS);
        this.menuView = sbMenuView.toString();
    }


    /**
     * In the case that an application has several menus, if isRootMenu is true,
     * then this is the main menu of the application and the option "0. Exit the
     * application" will be added as the first option.
     */
    public boolean isRootMenu() {
        return isRootMenu;
    }

    public void setRootMenu(boolean rootMenu) {
        isRootMenu = rootMenu;
    }

    /**
     * The submenus of this menu, or null if this is a leaf menu.
     */
    public List<Menu> getSubMenus() {
        return subMenus;
    }

    /**
     * Sets the list of submenus for this menu. Each submenu will have its parent menu
     * set to the current menu, and their titles will be added to the options list. However,
     * the submenus will be rendered with a different style in the generateMenuView() method.
     *
     * @param subMenus the list of submenus to be associated with the current menu
     * @throws MenuException if an error occurs while setting the submenus
     */
    public void setSubMenus(List<Menu> subMenus) throws MenuException {
        if (subMenus == null) {
            this.subMenus = null;
            return;
        }

        // Copia defensiva: evita listas de tamaño fijo (Arrays.asList) o no modificables
        List<Menu> mutable = new ArrayList<>(subMenus);

        // The submenus will added to the options list too but renders with different
        // style in generateMenuView() method.
        for (Menu subMenu : mutable) {
            subMenu.setParentMenu(this);
            this.addOption(subMenu);
        }
        this.subMenus = mutable;
    }

    // Methods of the object Menu.

    /**
     * Adds a submenu to this menu.
     * Note: when adding a submenu, their title will be added to the options list.
     *
     * @param childMenu The submenu to add.
     * @throws MenuException If the child menu is this menu or if the child menu is a root menu.
     */
    public void addSubMenu(Menu childMenu) throws MenuException {
        if (childMenu == null) {
            error(logger, MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
            throw new MenuException(MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
        }

        // Regla: Evitar ciclos y asegurar padre único
        if (childMenu == this) {
            error(logger, MenuErrors.ERR_MENU_CANNOT_POINT_TO_ITSELF);
            throw new MenuException(MenuErrors.ERR_MENU_CANNOT_POINT_TO_ITSELF);
        }
        if (childMenu.getIsRootMenu()) {
            error(logger, MenuErrors.ERR_ROOTMENU_CANT_POINT_TO_ANOTHER_MENU);
            throw new MenuException(MenuErrors.ERR_ROOTMENU_CANT_POINT_TO_ANOTHER_MENU);
        }

        // Asegura lista inicializada y mutable
        if (this.subMenus == null) {
            this.subMenus = new ArrayList<>();
        } else {
            try {
                this.subMenus.add(null);
                this.subMenus.removeLast();
            } catch (UnsupportedOperationException ex) {
                this.subMenus = new ArrayList<>(this.subMenus);
            }
        }

        childMenu.setParentMenu(this);
        this.subMenus.add(childMenu);
        this.addOption(childMenu);
    }


    // Methods


    /**
     * Removes the specified sub-menu from the current menu. If the sub-menu cannot
     * be removed due to certain conditions (e.g., null reference, not found, or
     * invalid state), an exception is thrown.
     *
     * @param childMenu The sub-menu to be removed from the current menu.
     *                  Must not be null and should exist within the current sub-menus list.
     * @throws MenuException Thrown when any of the following conditions occur:
     *                       1. The provided sub-menu is null.
     *                       2. The current menu's sub-menus collection is null.
     *                       3. The sub-menu to remove is not found in the sub-menus list.
     *                       4. Attempting to remove a root menu that contains additional sub-menus.
     */
    public void removeSubMenu(Menu childMenu) throws MenuException {
        if (childMenu == null) {
            error(logger, MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
            throw new MenuException(MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
        }
        if (this.subMenus == null) {
            error(logger, MenuErrors.ERR_SUBMENUS_CANNOT_BE_NULL);
            throw new MenuException(MenuErrors.ERR_SUBMENUS_CANNOT_BE_NULL);
        }
        if (this.subMenus.isEmpty()) {
            error(logger, MenuErrors.ERR_SUBMENU_NOT_FOUND);
            throw new MenuException(MenuErrors.ERR_SUBMENU_NOT_FOUND);
        }

        if (!this.subMenus.contains(childMenu)) {
            warn(logger, MenuErrors.ERR_SUBMENU_NOT_FOUND);
            return;
        }

        if (childMenu.getIsRootMenu() && this.subMenus.size() > 1) {
            error(logger, MenuErrors.ERR_ROOTMENU_WITH_SUBMENUS_CANT_BE_REMOVED);
            throw new MenuException(MenuErrors.ERR_ROOTMENU_WITH_SUBMENUS_CANT_BE_REMOVED);
        }
        childMenu.setParentMenu(null); //Needs to remove the reference to this in the child menu, too.
        this.removeOption(childMenu.getTitle());
        this.subMenus.remove(childMenu);
    }

    /**
     * Adds a new option to the menu.
     *
     * @param optionText the text for the option to be added. It must be non-null and non-empty.
     * @throws MenuException if the optionText is null, empty, or already exists in the menu options.
     */
    public void addOption(String optionText) throws MenuException {
        if (optionText == null || optionText.isEmpty()) {
            error(logger, MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
            throw new MenuException(MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
        }
        if (this.getOptions() == null) {
            throw new MenuException(MenuErrors.ERR_OPTIONS_CANNOT_BE_NULL);
        }
        if (this.getOptions().contains(optionText)) {
            error(logger, MenuErrors.ERR_OPTION_ALREADY_EXISTS);
            throw new MenuException(MenuErrors.ERR_OPTION_ALREADY_EXISTS);
        } else {
            optionText = addNumbertoOptionMenu(optionText, this.getOptions().size());
        }
        this.getOptions().add(optionText);
    }

    /**
     * Adds a submenu option to the current menu. This method associates the provided
     * submenu with the current menu, formats the option text for the submenu, and
     * appends it to the list of options in the current menu.
     *
     * @param subMenu The submenu to be added to the current menu. Must not be null.
     * @throws MenuException If the provided submenu is null.
     */
    public void addOption(Menu subMenu) throws MenuException {
        if (subMenu == null) {
            error(logger, MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
            throw new MenuException(MenuErrors.ERR_MENU_OBJECT_CANNOT_BE_NULL);
        }
        if (this.getOptions() == null) {
            this.setOptions(new ArrayList<>());
        }
        subMenu.setParentMenu(this);
        String optionText = formatOptionTextAsSubmenuOptionText(subMenu.getTitle());
        optionText = addNumbertoOptionMenu(optionText, this.getOptions().size());
        this.getOptions().add(optionText);
        subMenu.setTitle(optionText); //Needed for looking for aftewards (in removeOption() method).
    }

    /**
     * Removes an option from the options list.
     *
     * @param optionText The option to remove.
     */
    public void removeOption(String optionText) throws MenuException {
        if (optionText == null || optionText.isEmpty()) {
            error(logger, MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
            throw new MenuException(MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
        }
        this.getOptions().remove(optionText);
    }

    /**
     * Generates a string representation of the Menu object.
     * Don't show the menuview property because of their length.
     *
     * @return A string containing the state and attributes of the Menu object,
     * including its options, title, message, selected option, root menu status,
     * parent menu title (if present), and a summary of its sub-menus.
     */
    @Override
    public String toString() {
        return "Menu{" +
                "options=" + CollectionToString(this.getOptions(), true, 20) +
                ", title=" + this.getTitle() +
                ", message=" + this.getMessage() +
                ", selectedOption=" + this.getSelectedOption() +
                ", isRootMenu=" + this.getIsRootMenu() +
                ", parentMenu=" + (this.getParentMenu() != null ?
                this.getParentMenu().getTitle() : "null") +
                ", subMenus=" + CollectionToString(this.getSubMenus(), true, 20) +
                '}';
    }

    // Helper methods

    /**
     * Adds a number as a prefix to the specified option in the menu.
     * If the option already contains a numeric prefix, it returns the option unchanged.
     *
     * @param theOption The menu option to which a numeric prefix needs to be added.
     *                  Must not be null or empty.
     * @param index     The numerical index to be added as a prefix to the given option.
     * @return A string representing the menu option with the numerical prefix added,
     * or the original option if it already contains a numeric prefix.
     * @throws MenuException If the provided option is null or empty.
     */
    private String addNumbertoOptionMenu(String theOption, int index) throws MenuException {
        if (theOption == null || theOption.isEmpty()) {
            error(logger, MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
            throw new MenuException(MenuErrors.ERR_OPTION_TO_REMOVE_CAN_T_BE_NULL_OR_EMPTY);
        }
        //It's validates the argument 'theoption' has no number added yet.
        if (theOption.substring(1, 2).matches("\\d")) {
            return theOption;
        } else {
            return index + ". " + theOption;
        }
    }

    /**
     * Checks if the provided option corresponds to the title of a submenu
     * within the current menu's list of submenus.
     *
     * @param option the title of the option to check
     * @return true if the option matches the title of a submenu, false otherwise
     */
    private boolean isOptionALinkToMenu(String option) {
        for (Menu menu : this.getSubMenus()) {
            if (menu.getTitle().equals(option)) return true;
        }
        return false;
    }

    /**
     * Formats the given option text by converting the content within parentheses
     * to uppercase while retaining the rest of the text unchanged.
     *
     * @param optionText the option text to be formatted, which must include
     *                   a substring enclosed in parentheses
     * @return the formatted text where the parentheses' content is uppercase
     */
    private static String formatOptionTextAsSubmenuOptionText(String optionText) throws MenuException {
        if (optionText == null || optionText.isEmpty()) {
            throw new MenuException(MenuErrors.ERR_OPTION_CANNOT_BE_NULL_OR_EMPTY);
        }
        if (!optionText.contains("(")) {
            optionText = "(" + optionText;
        }
        if (!optionText.contains(")")) {
            optionText = optionText + ")";
        }
        return optionText.toUpperCase();
    }
}