package es.nom.juanfranciscoruiz.utiles;

import java.nio.charset.Charset;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.SortedMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class with various utility methods frequently used by other classes in the
 * application
 *
 * @author hamfree
 */
public class Util {

    /**
     * For debugging.
     */
    private static final Logger logger = LoggerFactory.getLogger(Util.class);

    final static String SL = IO.getLS();

    /**
     * We prevent it from being instantiated
     */
    private Util() {
    }

    /**
     * Returns in a map the existing CPUs on the PC, the free memory available
     * to the virtual machine (VM), the maximum amount of memory the VM will
     * attempt to use, and the total amount of memory currently available for
     * current and future objects, measured in bytes.
     *
     * @return a map with four data pairs:
     *
     * <ol>
     * <li> Key: "Processor Cores". Value: The number of CPU cores available to
     * the VM.</li>
     * <li> Key: "Free Memory". Value: the free memory available for the VM</li>
     * <li> Key: "Available Memory" Value: The maximum amount of memory that the
     * VM will attempt to use</li>
     * <li> Key: "Total Memory" Value: The total amount of memory currently
     * available in the VM for current and future objects.</li>
     * </ol>
     */
    public static Map<String, String> getFeaturesAsMap() {
        HashMap<String, String> hm = new HashMap<>();

        Runtime rt = Runtime.getRuntime();
        NumberFormat numberFormatter = NumberFormat.getNumberInstance(Locale.getDefault());

        System.gc();
        String freeMemory = numberFormatter.format(rt.freeMemory());
        String maxMemory = numberFormatter.format(rt.maxMemory());
        String totalMemmory = numberFormatter.format(rt.totalMemory());

        hm.put("Processor Cores", String.valueOf(rt.availableProcessors()));
        hm.put("Free Memory", freeMemory);
        hm.put("Available Memory", maxMemory);
        hm.put("Total Memory", totalMemmory);
        return hm;
    }

    /**
     * Returns the system properties in a map
     *
     * @return a map with the properties of the system.
     */
    public static Map<String, String> getSystemPropertiesAsMap() {
        HashMap<String, String> hm = new HashMap<>();

        Properties p = System.getProperties();

        p.forEach((key, value) -> hm.put(String.valueOf(key), String.valueOf(value)));
        return hm;
    }

    /**
     * Gets all charsets supported by the current JVM.
     *
     * @return una lista con todos los charsets soportados por la MVJ actual.
     */
    public static List<Charset> getAllCharsets() {
        SortedMap<String, Charset> sm;
        ArrayList<Charset> al = null;
        sm = Charset.availableCharsets();
        Iterator<Charset> it = sm.values().iterator();
        al = new ArrayList<>();
        while (it.hasNext()) {
            Charset ch = it.next();
            al.add(ch);
        }
        return al;
    }

    /**
     * Processes lists and maps to improve the output of the application
     * objects' 'toString()' method.
     *
     * @param obj the map or list whose elements you want to display or indicate
     * its type and size.
     * @param showValues boolean, if true, a string with the elements of the 
     * list or map will be returned. If false, a string with the type of object 
     * and the number of elements it contains will be returned.
     * @param maxElements If values ​​are to be returned, sets the maximum number 
     * of items whose textual representation will be returned in the string.
     * @return a string with the textual representation of the elements 
     * contained in the list or map or the type of the object and the number of 
     * elements it contains. If the object passed is neither a map nor a list 
     * the string returned is generated by the static method String.valueOf(). 
     * If the object is null it returns the string "null".
     */
    public static String CollectionToString(Object obj, boolean showValues, int maxElements) {

        StringBuilder sb = new StringBuilder();

        if (obj == null) {
            sb.append("null");
        } else {
            Class<?> clazz = obj.getClass();
            if (clazz.isAssignableFrom(ArrayList.class)) {
                List<?> l = (List) obj;
                if (showValues) {
                    sb.append("[");
                    if (l.size() < maxElements) {
                        for (Object o : l.toArray()) {
                            sb.append("'").append(String.valueOf(o)).append("'").append(" ");
                        }
                    } else {
                        for (int i = 0; i < maxElements; i++) {
                            sb.append("'").append(String.valueOf(l.get(i))).append("'").append(" ");
                        }
                        sb.append(" ...");
                    }
                    sb.append("]");
                } else {
                    sb.append(obj.getClass().getCanonicalName())
                            .append(" ")
                            .append(String.valueOf(l.size()))
                            .append(" items.");
                }

            } else if (clazz.isAssignableFrom(java.util.HashMap.class)) {
                Map<?, ?> m = (Map) obj;
                if (showValues) {
                    sb.append("[");
                    if (m.size() < maxElements) {
                        for (Iterator<?> it = m.entrySet().iterator(); it.hasNext();) {
                            Map.Entry<?, ?> e = (Map.Entry<?, ?>) it.next();
                            sb.append("{'").append(String.valueOf(e.getKey())).append("'->'").append(String.valueOf(e.getValue())).append("'}").append(" ");
                        }
                    } else {
                        int i = 0;
                        for (Iterator<?> it = m.entrySet().iterator(); it.hasNext();) {
                            if (i < maxElements) {
                                Map.Entry<?, ?> e = (Map.Entry<?, ?>) it.next();
                                sb.append("{'").append(String.valueOf(e.getKey())).append("'->'").append(String.valueOf(e.getValue())).append("'}").append(" ");
                                i++;
                            } else {
                                sb.append(" ...");
                                break;
                            }
                        }
                    }
                    sb.append("]");
                } else {
                    sb.append(obj.getClass().getCanonicalName())
                            .append(" ")
                            .append(String.valueOf(m.size()))
                            .append(" items.");
                }
            } else {
                sb.append(String.valueOf(obj));
            }
        }
        return sb.toString();
    }
}
